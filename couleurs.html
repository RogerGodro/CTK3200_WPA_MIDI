<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Launchpad MK2 â€” Paint (Simple & Fun)</title>
<style>
  :root{
    --bg:#071017; --panel:#07141a; --muted:#9fb3bf; --accent:#44f0a8;
  }
  body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;background:linear-gradient(180deg,#031018 0%, #071017 100%);color:#e7f6f2;padding:20px;}
  h1{margin:0 0 8px;font-size:20px}
  .wrap{display:flex;gap:20px;align-items:flex-start}
  .left{width:560px}
  .right{width:200px}
  .controls{display:flex;gap:8px;align-items:center;margin:8px 0 12px}
  button, select{background:var(--panel);border:1px solid rgba(255,255,255,0.05);color:var(--muted);padding:8px 10px;border-radius:8px;cursor:pointer}
  button:hover{filter:brightness(1.05)}
  #grid{display:grid;grid-template-columns:repeat(8,48px);grid-gap:8px;padding:12px;background:rgba(255,255,255,0.02);border-radius:10px}
  .pad{width:48px;height:48px;border-radius:8px;background:#000;box-shadow:inset 0 -4px 8px rgba(0,0,0,0.6);cursor:pointer;display:flex;align-items:center;justify-content:center;transition:box-shadow 160ms, transform 120ms}
  .pad:active{transform:translateY(1px)}
  .small{font-size:13px;color:var(--muted)}
  .palette{display:flex;flex-direction:column;gap:8px;align-items:center;padding:6px;background:rgba(255,255,255,0.02);border-radius:10px}
  .colorBtn{width:68px;height:36px;border-radius:10px;border:2px solid rgba(255,255,255,0.06);cursor:pointer;display:flex;align-items:center;justify-content:center;font-weight:700}
  .sel{outline:3px solid rgba(255,255,255,0.12);transform:scale(1.03)}
  .meta{margin-top:10px;font-size:13px;color:var(--muted)}
  .row{display:flex;gap:8px;align-items:center}
  .toggle{padding:6px 8px;border-radius:8px;background:#0b1b2a;border:1px solid rgba(255,255,255,0.03);color:#bfe6cf}
  .status{margin-top:12px;color:#9db1b6}
  .flash{animation:flash 700ms ease-in-out;}
  @keyframes flash{0%{transform:scale(1)}50%{transform:scale(1.08)}100%{transform:scale(1)}}
  footer{margin-top:14px;color:#9db1b6;font-size:13px}
</style>
</head>
<body>
  <h1>Launchpad MK2 â€” Paint (Simple â€¢ Ludique â€¢ ImprÃ©ssif)</h1>

  <div class="controls">
    <button id="connectBtn">ðŸ”Œ Connecter</button>
    <select id="inSelect"></select>
    <select id="outSelect"></select>

    <div style="margin-left:12px" class="small">Mode:</div>
    <select id="modeSel" style="width:120px">
      <option value="press">Press (peindre)</option>
      <option value="toggle">Toggle (basculer)</option>
    </select>

    <button id="pipetteBtn" class="toggle">Pipette: OFF</button>
    <button id="mirrorH">Mirror H</button>
    <button id="mirrorV">Mirror V</button>
  </div>

  <div class="wrap">
    <div class="left">
      <div id="grid"></div>
      <div style="display:flex;gap:8px;margin-top:10px">
        <button id="clearBtn">Effacer</button>
        <button id="fillBtn">Remplir</button>
        <button id="rainbowBtn">Rainbow</button>
        <button id="undoBtn" disabled>Annuler</button>
      </div>
      <div class="meta">Astuce: appuie sur un bouton rond en haut du Launchpad pour changer la couleur. Utilise Left/Right (top) pour changer la palette.</div>
    </div>

    <div class="right">
      <div class="small" style="margin-bottom:6px">Palette (haut â†’ bas comme sur ton Launchpad)</div>
      <div class="palette" id="paletteUI"></div>

      <div class="meta" style="margin-top:10px">Couleur sÃ©lectionnÃ©e:</div>
      <div id="selected" style="height:36px;border-radius:8px;margin-top:8px;border:2px solid rgba(255,255,255,0.04)"></div>

      <div class="status" id="status">Ã‰tat: DÃ©connectÃ©</div>
    </div>
  </div>

  <footer>Mapping exact utilisÃ© â€” pads: 11..88, boutons droite: ordre physique hautâ†’bas.</footer>

<script>
/* --------------------
   MAPPING (exact, validated)
   Pads: notes 11..88 (rows bottom->top)
   Right buttons: physical topâ†’bottom: 19,29,39,49,59,69,79,89
   Top bar CC: left=106 right=107
   -------------------- */
const PAD_NOTES = [
 11,12,13,14,15,16,17,18,
 21,22,23,24,25,26,27,28,
 31,32,33,34,35,36,37,38,
 41,42,43,44,45,46,47,48,
 51,52,53,54,55,56,57,58,
 61,62,63,64,65,66,67,68,
 71,72,73,74,75,76,77,78,
 81,82,83,84,85,86,87,88
];

const RIGHT_BUTTONS = [19,29,39,49,59,69,79,89]; // physical top->bottom
const CC_LEFT = 106, CC_RIGHT = 107;

/* --------------------
   UI + State
   -------------------- */
const gridEl = document.getElementById('grid');
const paletteUI = document.getElementById('paletteUI');
const selectedEl = document.getElementById('selected');
const statusEl = document.getElementById('status');
const inSelect = document.getElementById('inSelect');
const outSelect = document.getElementById('outSelect');

let midiAccess = null, midiIn = null, midiOut = null;
let pipette = false;
let mode = 'press';
let mirrorH = false, mirrorV = false;
let undoStack = [];

/* default palettes â€” 7 colors mapped to velocities, plus the display color at index 7 (record arm) */
let palettes = [
  [
    {hex:'#ff5b5b', vel:5}, {hex:'#ffb86b', vel:13}, {hex:'#fff56b', vel:21},
    {hex:'#78ff78', vel:29}, {hex:'#79ffd6', vel:37}, {hex:'#6fa8ff', vel:45},
    {hex:'#c97bff', vel:53}
  ],
  [
    {hex:'#001f3f', vel:7},{hex:'#0d6efd', vel:15},{hex:'#00b5d8', vel:23},
    {hex:'#00d184', vel:31},{hex:'#ffd43b', vel:39},{hex:'#ff6bcb', vel:47},
    {hex:'#ffffff', vel:3}
  ]
];
let paletteIndex = 0;
let selectedIdx = 0;

/* build grid UI */
PAD_NOTES.forEach(note=>{
  const el = document.createElement('div');
  el.className = 'pad';
  el.dataset.note = note;
  el.style.background = '#000';
  el.addEventListener('mousedown', ()=>onPadUI(note));
  el.addEventListener('touchstart', (e)=>{ e.preventDefault(); onPadUI(note); });
  gridEl.appendChild(el);
});

/* palette UI (vertical, top->bottom) */
function renderPalette(){
  paletteUI.innerHTML = '';
  const p = palettes[paletteIndex];
  // ensure we have exactly 8 visual slots (7 selectable + 1 display)
  for(let i=0;i<8;i++){
    const slot = document.createElement('div');
    slot.className = 'colorBtn';
    // If i < 7 -> color, else display slot uses selected color
    if(i < 7){
      const c = p[i % p.length];
      slot.style.background = c.hex;
      if(i === selectedIdx) slot.classList.add('sel');
      slot.onclick = ()=>{ selectColor(i, true); flashRecordArm(); };
    } else {
      // display bottom (record arm) reflect selected color
      const disp = p[selectedIdx % p.length];
      slot.style.background = disp.hex;
      slot.style.border = '2px dashed rgba(255,255,255,0.06)';
      slot.onclick = ()=>{ /* nothing */ };
    }
    paletteUI.appendChild(slot);
  }
  const disp = palettes[paletteIndex][selectedIdx];
  selectedEl.style.background = disp.hex;
}
renderPalette();

/* helpers to send note on/off */
function sendNoteOn(note, vel){
  if(!midiOut) return;
  midiOut.send([0x90, note, vel]);
}
function sendNoteOff(note){
  if(!midiOut) return;
  midiOut.send([0x80, note, 0]);
}

/* flash record arm visually and hardware */
function flashRecordArm(){
  const recordNote = RIGHT_BUTTONS[RIGHT_BUTTONS.length - 1]; // bottom physical
  const disp = palettes[paletteIndex][selectedIdx];
  // quick hardware flash
  if(midiOut){
    sendNoteOn(recordNote, disp.vel || 127);
    setTimeout(()=> sendNoteOn(recordNote, 0), 140);
  }
  // UI flash on the display slot
  const slots = paletteUI.children;
  if(slots && slots.length === 8){
    const displaySlot = slots[7];
    displaySlot.classList.add('flash');
    setTimeout(()=>displaySlot.classList.remove('flash'), 600);
  }
}

/* select color */
function selectColor(i, fromUI=false){
  if(i < 0) i = palettes[paletteIndex].length - 1;
  selectedIdx = i;
  renderPalette();
  flashRecordArm();
}

/* handle click on UI pad */
function onPadUI(note){
  if(pipette){
    // read pad color from state (we track color on UI only)
    const el = document.querySelector(`.pad[data-note="${note}"]`);
    const bg = el.style.background || '#000';
    // find best matching color in palette and set selected
    const p = palettes[paletteIndex];
    let idx = p.findIndex(c=>c.hex.toLowerCase() === bg.toLowerCase());
    if(idx === -1) {
      // if not found, add as temporary slot (replace current)
      p[selectedIdx] = {hex:bg, vel: p[selectedIdx].vel};
      idx = selectedIdx;
    }
    selectColor(idx, true);
    pipette = false;
    document.getElementById('pipetteBtn').textContent = 'Pipette: OFF';
    return;
  }

  applyPaint(note);
}

/* paint logic with mirror and mode */
function applyPaint(note){
  pushUndo();
  const col = palettes[paletteIndex][selectedIdx];
  // paint main
  lightPad(note, col);
  // mirror H/V if enabled
  const idx = PAD_NOTES.indexOf(note);
  if(idx === -1) return;
  const row = Math.floor(idx / 8); // 0..7 (bottom->top)
  const colIdx = idx % 8;
  if(mirrorH){
    const mirrorCol = 7 - colIdx;
    const mirrorIdx = row*8 + mirrorCol;
    const mirrorNote = PAD_NOTES[mirrorIdx];
    lightPad(mirrorNote, col);
  }
  if(mirrorV){
    const mirrorRow = 7 - row;
    const mirrorIdx = mirrorRow*8 + colIdx;
    const mirrorNote = PAD_NOTES[mirrorIdx];
    lightPad(mirrorNote, col);
  }
}

/* low-level: set pad on UI + hardware */
function lightPad(note, color){
  // UI
  const el = document.querySelector(`.pad[data-note="${note}"]`);
  if(el) el.style.background = color.hex;
  // hardware: Note On with velocity mapping
  if(midiOut) sendNoteOn(note, color.vel);
  // if mode toggle, implement toggling: we check current background (approx)
  // BUT for simplicity we always set color in both modes here; toggle implemented when note received from hardware
}

/* UNDO */
function pushUndo(){
  const snapshot = PAD_NOTES.map(n=>{
    const el = document.querySelector(`.pad[data-note="${n}"]`);
    return el ? el.style.background : '#000';
  });
  undoStack.push(snapshot);
  document.getElementById('undoBtn').disabled = false;
}
function undo(){
  if(undoStack.length === 0) return;
  const snap = undoStack.pop();
  PAD_NOTES.forEach((n,i)=>{
    const el = document.querySelector(`.pad[data-note="${n}"]`);
    if(el){ el.style.background = snap[i]; }
    // send hardware updates for consistency
    const pcol = palettes[paletteIndex].find(c => c.hex.toLowerCase() === (snap[i]||'#000').toLowerCase());
    if(pcol && midiOut) sendNoteOn(n, pcol.vel);
    if(!pcol && midiOut) sendNoteOn(n, 0);
  });
  if(undoStack.length === 0) document.getElementById('undoBtn').disabled = true;
}

/* clear / fill / rainbow */
document.getElementById('clearBtn').addEventListener('click', ()=>{
  pushUndo();
  PAD_NOTES.forEach(n=>{
    const el = document.querySelector(`.pad[data-note="${n}"]`);
    if(el) el.style.background = '#000';
    if(midiOut) sendNoteOn(n, 0);
  });
});
document.getElementById('fillBtn').addEventListener('click', ()=>{
  pushUndo();
  const c = palettes[paletteIndex][selectedIdx];
  PAD_NOTES.forEach(n=>{
    const el = document.querySelector(`.pad[data-note="${n}"]`);
    if(el) el.style.background = c.hex;
    if(midiOut) sendNoteOn(n, c.vel);
  });
});
document.getElementById('rainbowBtn').addEventListener('click', ()=>{
  pushUndo();
  const p = palettes[paletteIndex];
  PAD_NOTES.forEach((n,i)=>{
    const c = p[i % p.length];
    const el = document.querySelector(`.pad[data-note="${n}"]`);
    if(el) el.style.background = c.hex;
    if(midiOut) sendNoteOn(n, c.vel);
  });
});
document.getElementById('undoBtn').addEventListener('click', undo);

/* toggles */
document.getElementById('pipetteBtn').addEventListener('click', ()=>{
  pipette = !pipette;
  document.getElementById('pipetteBtn').textContent = pipette ? 'Pipette: ON' : 'Pipette: OFF';
});
document.getElementById('modeSel').addEventListener('change', (e)=> { mode = e.target.value; });

document.getElementById('mirrorH').addEventListener('click', ()=>{
  mirrorH = !mirrorH; document.getElementById('mirrorH').style.opacity = mirrorH?1:0.6;
});
document.getElementById('mirrorV').addEventListener('click', ()=>{
  mirrorV = !mirrorV; document.getElementById('mirrorV').style.opacity = mirrorV?1:0.6;
});

/* -----------------------------------
   MIDI: connect, listen, react
   ----------------------------------- */
document.getElementById('connectBtn').addEventListener('click', async ()=>{
  if(!navigator.requestMIDIAccess){ alert('WebMIDI non supportÃ©'); return; }
  try{
    midiAccess = await navigator.requestMIDIAccess({sysex:false});
    // populate selects
    inSelect.innerHTML = ''; outSelect.innerHTML = '';
    midiAccess.inputs.forEach(i=>{ const o = document.createElement('option'); o.value = i.id; o.textContent = i.name; inSelect.appendChild(o); });
    midiAccess.outputs.forEach(o2=>{ const o = document.createElement('option'); o.value = o2.id; o.textContent = o2.name; outSelect.appendChild(o); });
    // auto-select first Launchpad if present
    for(const inp of midiAccess.inputs.values()){
      if(inp.name.toLowerCase().includes('launchpad')){ inSelect.value = inp.id; break; }
    }
    for(const out of midiAccess.outputs.values()){
      if(out.name.toLowerCase().includes('launchpad')){ outSelect.value = out.id; break; }
    }
    // wire chosen ports
    midiIn = midiAccess.inputs.get(inSelect.value);
    midiOut = midiAccess.outputs.get(outSelect.value);
    if(midiIn) midiIn.onmidimessage = onMIDIMessage;
    statusEl.textContent = `Ã‰tat: connectÃ© (${ (midiOut && midiOut.name) ? midiOut.name : 'pas de sortie' })`;
    // initialize LEDs: clear all, then set record arm display to current color
    initializeDevice();
  }catch(err){ console.error(err); alert('Erreur MIDI: '+err.message); }
});

/* when user changes selects */
inSelect.addEventListener('change', ()=>{ midiIn = midiAccess.inputs.get(inSelect.value); if(midiIn) midiIn.onmidimessage = onMIDIMessage; });
outSelect.addEventListener('change', ()=>{ midiOut = midiAccess.outputs.get(outSelect.value); initializeDevice(); });

function initializeDevice(){
  // clear all hardware LEDs quickly
  if(!midiOut) return;
  PAD_NOTES.forEach(n=> sendNoteOn(n,0));
  // set recorded selected color to bottom right button (record arm)
  const dispNote = RIGHT_BUTTONS[RIGHT_BUTTONS.length-1];
  const disp = palettes[paletteIndex][selectedIdx];
  sendNoteOn(dispNote, disp.vel);
  // set right buttons' LEDs to approximate palette colors so user sees which to press
  RIGHT_BUTTONS.slice(0,7).forEach((btn,i)=>{
    const c = palettes[paletteIndex][i % palettes[paletteIndex].length];
    sendNoteOn(btn, c.vel);
  });
}

/* handle incoming midi from Launchpad */
let lastMsgTs = 0;
function onMIDIMessage(e){
  const now = Date.now();
  if(now - lastMsgTs < 20) { /* simple debounce */ }
  lastMsgTs = now;
  const [status, d1, d2] = e.data;
  const type = status & 0xF0;

  // Note On messages: pads + right buttons
  if(type === 0x90){
    if(d2 === 0) return; // note-off as velocity 0
    // right buttons?
    const rbIndex = RIGHT_BUTTONS.indexOf(d1);
    if(rbIndex !== -1){
      // if user pressed a right button: select that color
      if(rbIndex < 7){
        selectColor(rbIndex, false);
      }
      return;
    }
    // pads?
    const padIdx = PAD_NOTES.indexOf(d1);
    if(padIdx !== -1){
      if(pipette){
        // read current UI color of pad (if any) and set selection
        const el = document.querySelector(`.pad[data-note="${d1}"]`);
        const bg = el ? el.style.background : '#000';
        const p = palettes[paletteIndex];
        let idx = p.findIndex(c=>c.hex.toLowerCase() === bg.toLowerCase());
        if(idx === -1){
          // if unknown color, overwrite selected slot with this color
          p[selectedIdx] = {hex:bg, vel:p[selectedIdx].vel};
          idx = selectedIdx;
        }
        selectColor(idx,false);
        pipette = false; document.getElementById('pipetteBtn').textContent='Pipette: OFF';
        return;
      }
      // painting behavior depends on mode
      if(mode === 'press'){
        applyPaint(d1);
      } else {
        // toggle: check current UI color; if equal -> clear, else set
        const el = document.querySelector(`.pad[data-note="${d1}"]`);
        const cur = el ? (el.style.background || '#000') : '#000';
        const target = palettes[paletteIndex][selectedIdx].hex;
        if(cur.toLowerCase() === target.toLowerCase()){
          // clear it
          if(midiOut) sendNoteOn(d1, 0);
          if(el) el.style.background = '#000';
        } else {
          applyPaint(d1);
        }
      }
      return;
    }
  }

  // Control Change (top buttons)
  if(type === 0xB0){
    if(d1 === CC_LEFT && d2 > 0){
      paletteIndex = (paletteIndex - 1 + palettes.length) % palettes.length;
      // keep selected idx within bounds
      selectedIdx = Math.min(selectedIdx, palettes[paletteIndex].length - 1);
      renderPalette(); initializeDevice();
      return;
    }
    if(d1 === CC_RIGHT && d2 > 0){
      paletteIndex = (paletteIndex + 1) % palettes.length;
      selectedIdx = Math.min(selectedIdx, palettes[paletteIndex].length - 1);
      renderPalette(); initializeDevice();
      return;
    }
  }
}

/* keyboard shortcuts for quick demo (optional) */
window.addEventListener('keydown',(e)=>{
  if(e.key === 'z' && (e.ctrlKey || e.metaKey)){ undo(); e.preventDefault(); }
  if(e.key === 'p'){ pipette = !pipette; document.getElementById('pipetteBtn').textContent = pipette?'Pipette: ON':'Pipette: OFF'; }
});

/* small polish: ensure selected LED shown */
function updateSelectedDisplay(){
  const dispNote = RIGHT_BUTTONS[RIGHT_BUTTONS.length-1];
  const disp = palettes[paletteIndex][selectedIdx];
  selectedEl.style.background = disp.hex;
  if(midiOut) sendNoteOn(dispNote, disp.vel);
}

/* when changing selection, update LED */
function selectColor(i, fromUI=false){
  selectedIdx = i;
  renderPalette();
  updateSelectedDisplay();
  flashRecordArm();
}

/* initial call to show UI */
renderPalette();

</script>
</body>
</html>
