<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>ðŸŒ¸ Chord Machine v4</title>
    <link rel="manifest" href='data:application/manifest+json,{"name":"Chord Machine","short_name":"ChordMach","display":"fullscreen","orientation":"landscape","theme_color":"#0a0a0f","background_color":"#0a0a0f"}'>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Outfit:wght@300;400;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        
        :root {
            --bg-dark: #0a0a0f;
            --bg-panel: #141420;
            --bg-section: #1a1a2e;
            --accent-orange: #ff6b35;
            --accent-yellow: #ffc234;
            --accent-teal: #00d4aa;
            --accent-purple: #9d4edd;
            --accent-pink: #ff69b4;
            --accent-red: #ff4444;
            --accent-green: #44ff88;
            --text-primary: #f0f0f0;
            --text-secondary: #888;
        }
        
        html, body { height: 100%; overflow: hidden; touch-action: none; }
        
        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            background-image: 
                radial-gradient(ellipse at 20% 80%, rgba(157, 78, 221, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(255, 107, 53, 0.1) 0%, transparent 50%);
        }
        
        .app-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 8px;
            gap: 8px;
        }
        
        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: var(--bg-panel);
            border-radius: 10px;
            flex-shrink: 0;
        }
        
        .logo {
            font-family: 'Space Mono', monospace;
            font-size: 1.1rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-orange), var(--accent-yellow));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 2px;
        }
        
        .header-controls { display: flex; gap: 8px; align-items: center; }
        
        .header-btn {
            background: var(--bg-section);
            border: 2px solid var(--accent-orange);
            color: var(--accent-orange);
            padding: 6px 12px;
            border-radius: 6px;
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .header-btn:hover, .header-btn.active { background: var(--accent-orange); color: var(--bg-dark); }
        .header-btn.panic { border-color: var(--accent-red); color: var(--accent-red); }
        .header-btn.panic:hover { background: var(--accent-red); color: white; }
        .header-btn.connected { border-color: var(--accent-green); color: var(--accent-green); }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-red);
        }
        .status-dot.connected { background: var(--accent-green); box-shadow: 0 0 8px var(--accent-green); }
        
        /* Main Content */
        .main-content {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 8px;
            min-height: 0;
        }
        
        /* Left Panel - Main Controls */
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 0;
        }
        
        /* Chord Display */
        .chord-display {
            background: var(--bg-panel);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            flex-shrink: 0;
        }
        
        .chord-name {
            font-family: 'Space Mono', monospace;
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-orange), var(--accent-yellow));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .chord-notes {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 5px;
            font-family: 'Space Mono', monospace;
        }
        
        /* Control Panels Grid */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            flex: 1;
            min-height: 0;
        }
        
        .panel {
            background: var(--bg-panel);
            border-radius: 10px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .panel-title {
            font-family: 'Space Mono', monospace;
            font-size: 0.65rem;
            color: var(--accent-orange);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            flex-shrink: 0;
        }
        
        /* Button Grid */
        .btn-grid {
            display: grid;
            gap: 4px;
            flex: 1;
        }
        .btn-grid.cols-4 { grid-template-columns: repeat(4, 1fr); }
        .btn-grid.cols-3 { grid-template-columns: repeat(3, 1fr); }
        .btn-grid.cols-2 { grid-template-columns: repeat(2, 1fr); }
        
        .grid-btn {
            background: var(--bg-section);
            border: 1px solid var(--bg-section);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'Space Mono', monospace;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
            padding: 6px 2px;
            text-align: center;
        }
        
        .grid-btn:hover { border-color: var(--accent-orange); }
        .grid-btn.active {
            background: var(--accent-orange);
            color: var(--bg-dark);
            border-color: var(--accent-orange);
        }
        
        /* Root Note Selector */
        .root-selector {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 3px;
        }
        
        .root-btn {
            background: var(--bg-section);
            border: 1px solid var(--bg-section);
            border-radius: 4px;
            color: var(--text-primary);
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            padding: 8px 2px;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .root-btn:hover { border-color: var(--accent-yellow); }
        .root-btn.active {
            background: var(--accent-yellow);
            color: var(--bg-dark);
            border-color: var(--accent-yellow);
        }
        .root-btn.black { background: #222; }
        .root-btn.black.active { background: var(--accent-yellow); }
        
        /* Knobs */
        .knobs-row {
            display: flex;
            justify-content: space-around;
            gap: 10px;
            flex: 1;
            align-items: center;
        }
        
        .knob-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .knob {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: conic-gradient(from 135deg, var(--bg-section) 0deg, var(--accent-orange) 0deg, var(--accent-orange) 0deg, var(--bg-section) 0deg);
            border: 3px solid var(--accent-orange);
            position: relative;
            cursor: grab;
        }
        
        .knob::after {
            content: '';
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            width: 3px;
            height: 12px;
            background: var(--accent-orange);
            border-radius: 2px;
        }
        
        .knob-value {
            font-family: 'Space Mono', monospace;
            font-size: 1rem;
            font-weight: 700;
            color: var(--accent-orange);
        }
        
        .knob-label {
            font-size: 0.55rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }
        
        /* Virtual Keyboard */
        .keyboard-panel {
            background: var(--bg-panel);
            border-radius: 10px;
            padding: 10px;
            flex-shrink: 0;
        }
        
        .keyboard {
            display: flex;
            justify-content: center;
            height: 60px;
            position: relative;
        }
        
        .white-key {
            width: 28px;
            height: 60px;
            background: linear-gradient(180deg, #f8f8f8 0%, #e0e0e0 100%);
            border: 1px solid #999;
            border-radius: 0 0 4px 4px;
            cursor: pointer;
            transition: all 0.1s;
            z-index: 1;
        }
        
        .white-key:hover { background: linear-gradient(180deg, #fff 0%, #f0f0f0 100%); }
        .white-key.active { background: var(--accent-orange); }
        
        .black-key {
            width: 18px;
            height: 38px;
            background: linear-gradient(180deg, #333 0%, #111 100%);
            border-radius: 0 0 3px 3px;
            position: absolute;
            z-index: 2;
            cursor: pointer;
            transition: all 0.1s;
        }
        
        .black-key:hover { background: linear-gradient(180deg, #444 0%, #222 100%); }
        .black-key.active { background: var(--accent-purple); }
        
        /* Right Panel */
        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 0;
        }
        
        /* BPM Control */
        .bpm-control {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
        }
        
        .bpm-value {
            font-family: 'Space Mono', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-teal);
            min-width: 60px;
            text-align: center;
        }
        
        .bpm-btn {
            background: var(--bg-section);
            border: 1px solid var(--accent-teal);
            color: var(--accent-teal);
            width: 30px;
            height: 30px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.15s;
        }
        
        .bpm-btn:hover { background: var(--accent-teal); color: var(--bg-dark); }
        
        /* Loop Section */
        .loop-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .loop-circle {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: var(--bg-section);
            border: 4px solid var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.3s;
        }
        
        .loop-circle.recording { border-color: var(--accent-red); animation: pulse-red 1s infinite; }
        .loop-circle.playing { border-color: var(--accent-green); }
        .loop-circle.countdown { border-color: var(--accent-yellow); }
        
        @keyframes pulse-red {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.5); }
            50% { box-shadow: 0 0 20px 10px rgba(255, 68, 68, 0); }
        }
        
        .loop-icon {
            font-size: 1.5rem;
        }
        
        .loop-progress {
            position: absolute;
            inset: -4px;
            border-radius: 50%;
        }
        
        .bars-selector {
            display: flex;
            gap: 5px;
        }
        
        .bar-btn {
            background: var(--bg-section);
            border: 1px solid var(--text-secondary);
            color: var(--text-primary);
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            transition: all 0.15s;
        }
        
        .bar-btn.active {
            background: var(--accent-purple);
            border-color: var(--accent-purple);
            color: white;
        }
        
        /* Beat Section */
        .beat-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
        }
        
        .beat-btn {
            background: var(--bg-section);
            border: 1px solid var(--bg-section);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 0.55rem;
            padding: 8px 4px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
        }
        
        .beat-btn:hover { border-color: var(--accent-pink); }
        .beat-btn.active {
            background: var(--accent-pink);
            color: white;
            border-color: var(--accent-pink);
        }
        
        /* Volume Sliders */
        .volume-row {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }
        
        .volume-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .volume-slider {
            -webkit-appearance: none;
            width: 80px;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-section);
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-teal);
            cursor: pointer;
        }
        
        .volume-label {
            font-size: 0.55rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }
        
        /* MIDI Config */
        .midi-config {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .midi-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.65rem;
        }
        
        .midi-select {
            background: var(--bg-section);
            border: 1px solid var(--text-secondary);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.6rem;
        }
        
        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .modal-overlay.show { display: flex; }
        
        .modal {
            background: var(--bg-panel);
            border-radius: 15px;
            padding: 25px;
            max-width: 400px;
            width: 90%;
            border: 2px solid var(--accent-orange);
        }
        
        .modal-title {
            font-family: 'Space Mono', monospace;
            font-size: 1.2rem;
            color: var(--accent-orange);
            margin-bottom: 15px;
        }
        
        .modal-select-group {
            margin-bottom: 15px;
        }
        
        .modal-select-group label {
            display: block;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }
        
        .modal-select-group select {
            width: 100%;
            background: var(--bg-section);
            border: 1px solid var(--text-secondary);
            color: var(--text-primary);
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9rem;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        
        .modal-btn {
            padding: 10px 20px;
            border-radius: 6px;
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .modal-btn.secondary {
            background: transparent;
            border: 1px solid var(--text-secondary);
            color: var(--text-secondary);
        }
        
        .modal-btn.primary {
            background: var(--accent-orange);
            border: none;
            color: var(--bg-dark);
        }
        
        /* Responsive */
        @media (max-width: 900px) {
            .main-content { grid-template-columns: 1fr; }
            .right-panel { display: none; }
            .controls-grid { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <div class="logo">ðŸŒ¸ CHORD MACHINE</div>
            <div class="header-controls">
                <button class="header-btn panic" id="panicBtn" title="Stop All">ðŸ›‘ STOP</button>
                <button class="header-btn" id="midiBtn">
                    <span class="status-dot" id="statusDot"></span>
                    <span id="midiStatus">MIDI</span>
                </button>
                <button class="header-btn" id="fullscreenBtn">â›¶</button>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="main-content">
            <!-- Left Panel -->
            <div class="left-panel">
                <!-- Chord Display -->
                <div class="chord-display">
                    <div class="chord-name" id="chordName">C MAJ</div>
                    <div class="chord-notes" id="chordNotes">C E G</div>
                </div>
                
                <!-- Root Note Selector -->
                <div class="panel">
                    <div class="panel-title">Root Note</div>
                    <div class="root-selector" id="rootSelector">
                        <button class="root-btn active" data-root="0">C</button>
                        <button class="root-btn black" data-root="1">C#</button>
                        <button class="root-btn" data-root="2">D</button>
                        <button class="root-btn black" data-root="3">D#</button>
                        <button class="root-btn" data-root="4">E</button>
                        <button class="root-btn" data-root="5">F</button>
                        <button class="root-btn black" data-root="6">F#</button>
                        <button class="root-btn" data-root="7">G</button>
                        <button class="root-btn black" data-root="8">G#</button>
                        <button class="root-btn" data-root="9">A</button>
                        <button class="root-btn black" data-root="10">A#</button>
                        <button class="root-btn" data-root="11">B</button>
                    </div>
                </div>
                
                <!-- Controls Grid -->
                <div class="controls-grid">
                    <!-- Chord Type -->
                    <div class="panel">
                        <div class="panel-title">Chord Type</div>
                        <div class="btn-grid cols-4" id="chordTypeGrid">
                            <button class="grid-btn active" data-type="maj">MAJ</button>
                            <button class="grid-btn" data-type="min">MIN</button>
                            <button class="grid-btn" data-type="dim">DIM</button>
                            <button class="grid-btn" data-type="aug">AUG</button>
                            <button class="grid-btn" data-type="sus2">SUS2</button>
                            <button class="grid-btn" data-type="sus4">SUS4</button>
                            <button class="grid-btn" data-type="5">5TH</button>
                            <button class="grid-btn" data-type="add9">ADD9</button>
                        </div>
                    </div>
                    
                    <!-- Extensions -->
                    <div class="panel">
                        <div class="panel-title">Extension</div>
                        <div class="btn-grid cols-4" id="extensionGrid">
                            <button class="grid-btn active" data-ext="none">â€”</button>
                            <button class="grid-btn" data-ext="7">7</button>
                            <button class="grid-btn" data-ext="maj7">M7</button>
                            <button class="grid-btn" data-ext="9">9</button>
                            <button class="grid-btn" data-ext="11">11</button>
                            <button class="grid-btn" data-ext="13">13</button>
                            <button class="grid-btn" data-ext="6">6</button>
                            <button class="grid-btn" data-ext="69">6/9</button>
                        </div>
                    </div>
                    
                    <!-- Performance Mode -->
                    <div class="panel">
                        <div class="panel-title">Mode</div>
                        <div class="btn-grid cols-3" id="modeGrid">
                            <button class="grid-btn active" data-mode="hold">HOLD</button>
                            <button class="grid-btn" data-mode="arp">ARP</button>
                            <button class="grid-btn" data-mode="strum">STRUM</button>
                            <button class="grid-btn" data-mode="harp">HARP</button>
                            <button class="grid-btn" data-mode="random">RND</button>
                            <button class="grid-btn" data-mode="pulse">PULSE</button>
                        </div>
                    </div>
                    
                    <!-- Engine -->
                    <div class="panel">
                        <div class="panel-title">Engine</div>
                        <div class="btn-grid cols-3" id="engineGrid">
                            <button class="grid-btn active" data-engine="analog">ANALOG</button>
                            <button class="grid-btn" data-engine="fm">FM</button>
                            <button class="grid-btn" data-engine="epiano">E-PIANO</button>
                        </div>
                    </div>
                    
                    <!-- Effects -->
                    <div class="panel">
                        <div class="panel-title">Effects</div>
                        <div class="volume-row">
                            <div class="volume-item">
                                <input type="range" class="volume-slider" id="reverbSlider" min="0" max="100" value="30">
                                <span class="volume-label">Reverb</span>
                            </div>
                            <div class="volume-item">
                                <input type="range" class="volume-slider" id="delaySlider" min="0" max="100" value="0">
                                <span class="volume-label">Delay</span>
                            </div>
                            <div class="volume-item">
                                <input type="range" class="volume-slider" id="chorusSlider" min="0" max="100" value="0">
                                <span class="volume-label">Chorus</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Knobs -->
                    <div class="panel">
                        <div class="panel-title">Voicing</div>
                        <div class="knobs-row">
                            <div class="knob-container">
                                <div class="knob" id="voicingKnob"></div>
                                <div class="knob-value" id="voicingValue">0</div>
                                <div class="knob-label">Inversion</div>
                            </div>
                            <div class="knob-container">
                                <div class="knob" id="spreadKnob"></div>
                                <div class="knob-value" id="spreadValue">1</div>
                                <div class="knob-label">Spread</div>
                            </div>
                            <div class="knob-container">
                                <div class="knob" id="octaveKnob"></div>
                                <div class="knob-value" id="octaveValue">4</div>
                                <div class="knob-label">Octave</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Virtual Keyboard -->
                <div class="keyboard-panel">
                    <div class="keyboard" id="keyboard"></div>
                </div>
            </div>
            
            <!-- Right Panel -->
            <div class="right-panel">
                <!-- BPM -->
                <div class="panel">
                    <div class="panel-title">Tempo</div>
                    <div class="bpm-control">
                        <button class="bpm-btn" id="bpmDown">âˆ’</button>
                        <div class="bpm-value" id="bpmValue">120</div>
                        <button class="bpm-btn" id="bpmUp">+</button>
                    </div>
                </div>
                
                <!-- Loop -->
                <div class="panel">
                    <div class="panel-title">Loop</div>
                    <div class="loop-section">
                        <div class="loop-circle" id="loopCircle">
                            <svg class="loop-progress" viewBox="0 0 100 100">
                                <circle cx="50" cy="50" r="46" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="4"/>
                                <circle id="loopProgressCircle" cx="50" cy="50" r="46" fill="none" stroke="var(--accent-green)" stroke-width="4" stroke-dasharray="289" stroke-dashoffset="289" transform="rotate(-90 50 50)"/>
                            </svg>
                            <span class="loop-icon" id="loopIcon">â¬¤</span>
                        </div>
                        <div class="bars-selector" id="barsSelector">
                            <button class="bar-btn active" data-bars="1">1</button>
                            <button class="bar-btn" data-bars="2">2</button>
                            <button class="bar-btn" data-bars="4">4</button>
                            <button class="bar-btn" data-bars="8">8</button>
                        </div>
                    </div>
                </div>
                
                <!-- Beat -->
                <div class="panel">
                    <div class="panel-title">Beat</div>
                    <div class="beat-grid" id="beatGrid">
                        <button class="beat-btn" data-beat="0">OFF</button>
                        <button class="beat-btn" data-beat="1">ROCK</button>
                        <button class="beat-btn" data-beat="2">POP</button>
                        <button class="beat-btn" data-beat="3">FUNK</button>
                        <button class="beat-btn" data-beat="4">JAZZ</button>
                        <button class="beat-btn" data-beat="5">LATIN</button>
                        <button class="beat-btn" data-beat="6">HIP-HOP</button>
                        <button class="beat-btn" data-beat="7">ELECTRO</button>
                    </div>
                </div>
                
                <!-- Volume -->
                <div class="panel">
                    <div class="panel-title">Volume</div>
                    <div class="volume-row">
                        <div class="volume-item">
                            <input type="range" class="volume-slider" id="mainVolume" min="0" max="100" value="70">
                            <span class="volume-label">Main</span>
                        </div>
                        <div class="volume-item">
                            <input type="range" class="volume-slider" id="bassVolume" min="0" max="100" value="50">
                            <span class="volume-label">Bass</span>
                        </div>
                    </div>
                </div>
                
                <!-- MIDI Out -->
                <div class="panel">
                    <div class="panel-title">MIDI Out</div>
                    <div class="midi-config">
                        <div class="midi-row">
                            <span>Chords</span>
                            <select class="midi-select" id="chordChannel">
                                <option value="0">Ch 1</option>
                                <option value="1">Ch 2</option>
                                <option value="2">Ch 3</option>
                                <option value="3">Ch 4</option>
                            </select>
                        </div>
                        <div class="midi-row">
                            <span>Bass</span>
                            <select class="midi-select" id="bassChannel">
                                <option value="0">Ch 1</option>
                                <option value="1" selected>Ch 2</option>
                                <option value="2">Ch 3</option>
                                <option value="3">Ch 4</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- MIDI Modal -->
    <div class="modal-overlay" id="midiModal">
        <div class="modal">
            <div class="modal-title">ðŸŽ¹ Connexion MIDI</div>
            <div class="modal-select-group">
                <label>EntrÃ©e MIDI (contrÃ´leur)</label>
                <select id="modalMidiInput"><option value="">-- Aucune --</option></select>
            </div>
            <div class="modal-select-group">
                <label>Sortie MIDI (synthÃ©)</label>
                <select id="modalMidiOutput"><option value="">-- Audio interne --</option></select>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="modalCancel">Annuler</button>
                <button class="modal-btn primary" id="modalConnect">Connecter</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // ðŸŒ¸ CHORD MACHINE v4 - Complete Version
        // Proper multi-note handling - notes only stop
        // when ALL held notes are released
        // ============================================
        
        // Audio Context & Nodes
        let audioCtx = null;
        let masterGain = null;
        let reverbGain = null;
        let delayNode = null;
        let delayGain = null;
        let chorusGain = null;
        let convolver = null;
        
        // MIDI
        let midiAccess = null;
        let midiInput = null;
        let midiOutput = null;
        
        // ===== KEY FIX v4: Track ALL held input notes =====
        const heldInputNotes = new Set();
        
        // Active audio for the current chord
        let activeChordNodes = [];
        let activeBassNode = null;
        let arpInterval = null;
        let arpIndex = 0;
        
        // Loop
        let loopState = 'stopped';
        let loopBars = 1;
        let loopData = [];
        let loopStartTime = 0;
        let loopPlaybackTimeout = null;
        let countdownCount = 0;
        let metronomeTimeout = null;
        
        // Beat
        let beatInterval = null;
        let beatStep = 0;
        
        // State
        const state = {
            rootNote: 0,
            chordType: 'maj',
            extension: 'none',
            voicing: 0,
            spread: 1,
            octave: 4,
            mode: 'hold',
            engine: 'analog',
            bpm: 120,
            reverb: 0.3,
            delay: 0,
            chorus: 0,
            mainVolume: 0.7,
            bassVolume: 0.5,
            chordChannel: 0,
            bassChannel: 1,
            beat: 0
        };
        
        // Note names
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        // Chord intervals
        const chordIntervals = {
            maj: [0, 4, 7],
            min: [0, 3, 7],
            dim: [0, 3, 6],
            aug: [0, 4, 8],
            sus2: [0, 2, 7],
            sus4: [0, 5, 7],
            '5': [0, 7],
            add9: [0, 4, 7, 14]
        };
        
        // Extensions
        const extensions = {
            none: [],
            '7': [10],
            maj7: [11],
            '9': [10, 14],
            '11': [10, 14, 17],
            '13': [10, 14, 21],
            '6': [9],
            '69': [9, 14]
        };
        
        // Beat patterns (16 steps)
        const beatPatterns = {
            0: null,
            1: { kick: [0,8], snare: [4,12], hat: [0,2,4,6,8,10,12,14] }, // Rock
            2: { kick: [0,10], snare: [4,12], hat: [0,2,4,6,8,10,12,14] }, // Pop
            3: { kick: [0,3,6,10], snare: [4,12], hat: [0,2,4,6,8,10,12,14] }, // Funk
            4: { kick: [0,7,14], snare: [8], hat: [0,3,6,9,12,15] }, // Jazz
            5: { kick: [0,3,7,10], snare: [4,12], hat: [0,2,4,6,8,10,12,14] }, // Latin
            6: { kick: [0,4,8,12], snare: [4,12], hat: [2,6,10,14] }, // Hip-hop
            7: { kick: [0,4,8,12], snare: [4,12], hat: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] } // Electro
        };
        
        // ============================================
        // AUDIO INITIALIZATION
        // ============================================
        
        function initAudio() {
            if (audioCtx) return;
            
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            // Master gain
            masterGain = audioCtx.createGain();
            masterGain.gain.value = state.mainVolume;
            masterGain.connect(audioCtx.destination);
            
            // Reverb
            reverbGain = audioCtx.createGain();
            reverbGain.gain.value = state.reverb;
            reverbGain.connect(masterGain);
            
            // Create impulse response for reverb
            createReverb();
            
            // Delay
            delayNode = audioCtx.createDelay(1);
            delayNode.delayTime.value = 0.3;
            delayGain = audioCtx.createGain();
            delayGain.gain.value = state.delay;
            const delayFeedback = audioCtx.createGain();
            delayFeedback.gain.value = 0.3;
            delayNode.connect(delayGain);
            delayGain.connect(masterGain);
            delayNode.connect(delayFeedback);
            delayFeedback.connect(delayNode);
        }
        
        function createReverb() {
            const length = audioCtx.sampleRate * 2;
            const impulse = audioCtx.createBuffer(2, length, audioCtx.sampleRate);
            for (let c = 0; c < 2; c++) {
                const channel = impulse.getChannelData(c);
                for (let i = 0; i < length; i++) {
                    channel[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                }
            }
            convolver = audioCtx.createConvolver();
            convolver.buffer = impulse;
            convolver.connect(reverbGain);
        }
        
        // ============================================
        // CHORD GENERATION
        // ============================================
        
        function getChordNotes() {
            const root = state.rootNote + (state.octave * 12);
            let intervals = [...chordIntervals[state.chordType]];
            
            // Add extension
            if (state.extension !== 'none') {
                intervals = intervals.concat(extensions[state.extension]);
            }
            
            // Apply voicing (inversion)
            for (let i = 0; i < state.voicing; i++) {
                if (intervals.length > 1) {
                    intervals.push(intervals.shift() + 12);
                }
            }
            
            // Apply spread
            let notes = intervals.map((int, idx) => {
                const octaveOffset = Math.floor(idx / 3) * (state.spread - 1) * 12;
                return root + int + octaveOffset;
            });
            
            return notes;
        }
        
        function getBassNote() {
            return state.rootNote + ((state.octave - 1) * 12);
        }
        
        function updateChordDisplay() {
            const rootName = noteNames[state.rootNote];
            const typeName = state.chordType.toUpperCase();
            const extName = state.extension !== 'none' ? state.extension : '';
            
            document.getElementById('chordName').textContent = rootName + ' ' + typeName + extName;
            
            const notes = getChordNotes();
            const noteNamesStr = notes.map(n => noteNames[n % 12]).join(' ');
            document.getElementById('chordNotes').textContent = noteNamesStr;
        }
        
        // ============================================
        // AUDIO SYNTHESIS
        // ============================================
        
        function midiToFreq(midi) {
            return 440 * Math.pow(2, (midi - 69) / 12);
        }
        
        function createOscillator(freq, type, detune = 0) {
            const osc = audioCtx.createOscillator();
            osc.type = type;
            osc.frequency.value = freq;
            osc.detune.value = detune;
            return osc;
        }
        
        function createEnvelope(gainNode, attack = 0.015, decay = 0.1, sustain = 0.7, velocity = 1) {
            const now = audioCtx.currentTime;
            const vol = velocity * state.mainVolume * 0.3;
            gainNode.gain.setValueAtTime(0.0001, now);
            gainNode.gain.exponentialRampToValueAtTime(vol, now + attack);
            gainNode.gain.exponentialRampToValueAtTime(vol * sustain, now + attack + decay);
        }
        
        function releaseEnvelope(gainNode, release = 0.08) {
            const now = audioCtx.currentTime;
            gainNode.gain.cancelScheduledValues(now);
            gainNode.gain.setValueAtTime(gainNode.gain.value || 0.0001, now);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, now + release);
        }
        
        function playNoteAudio(midiNote, velocity = 0.8) {
            initAudio();
            
            const freq = midiToFreq(midiNote);
            const nodes = { oscillators: [], gain: null };
            
            // Create gain envelope
            nodes.gain = audioCtx.createGain();
            nodes.gain.connect(masterGain);
            if (state.reverb > 0) nodes.gain.connect(convolver);
            if (state.delay > 0) nodes.gain.connect(delayNode);
            
            // Create oscillators based on engine
            if (state.engine === 'analog') {
                const osc1 = createOscillator(freq, 'sawtooth', 0);
                const osc2 = createOscillator(freq, 'square', 7);
                osc1.connect(nodes.gain);
                osc2.connect(nodes.gain);
                osc1.start();
                osc2.start();
                nodes.oscillators.push(osc1, osc2);
            } else if (state.engine === 'fm') {
                const carrier = createOscillator(freq, 'sine');
                const modulator = audioCtx.createOscillator();
                modulator.frequency.value = freq * 2;
                const modGain = audioCtx.createGain();
                modGain.gain.value = freq * 0.5;
                modulator.connect(modGain);
                modGain.connect(carrier.frequency);
                carrier.connect(nodes.gain);
                modulator.start();
                carrier.start();
                nodes.oscillators.push(carrier, modulator);
            } else if (state.engine === 'epiano') {
                const osc1 = createOscillator(freq, 'sine');
                const osc2 = createOscillator(freq * 2, 'sine');
                const osc2Gain = audioCtx.createGain();
                osc2Gain.gain.value = 0.3;
                osc1.connect(nodes.gain);
                osc2.connect(osc2Gain);
                osc2Gain.connect(nodes.gain);
                osc1.start();
                osc2.start();
                nodes.oscillators.push(osc1, osc2);
            }
            
            createEnvelope(nodes.gain, 0.015, 0.1, 0.7, velocity);
            
            return nodes;
        }
        
        function stopNoteAudio(nodes) {
            if (!nodes || !nodes.gain) return;
            
            releaseEnvelope(nodes.gain, 0.08);
            
            setTimeout(() => {
                nodes.oscillators.forEach(osc => {
                    try { osc.stop(); } catch(e) {}
                });
            }, 100);
        }
        
        // ============================================
        // CHORD PLAYBACK
        // ============================================
        
        function playChord(velocity = 0.8) {
            stopChord();
            
            const notes = getChordNotes();
            const bassNote = getBassNote();
            
            // Record to loop if recording
            if (loopState === 'recording') {
                const time = audioCtx.currentTime - loopStartTime;
                loopData.push({ type: 'on', time, velocity });
            }
            
            if (state.mode === 'hold') {
                // Play all notes at once
                notes.forEach(note => {
                    if (midiOutput) {
                        sendMidiNoteOn(note, velocity, state.chordChannel);
                    } else {
                        activeChordNodes.push(playNoteAudio(note, velocity));
                    }
                });
                
                // Bass
                if (midiOutput) {
                    sendMidiNoteOn(bassNote, velocity * 0.8, state.bassChannel);
                } else {
                    activeBassNode = playNoteAudio(bassNote, velocity * state.bassVolume);
                }
                
            } else if (state.mode === 'arp' || state.mode === 'harp' || state.mode === 'random') {
                startArpeggiator(notes, velocity);
            } else if (state.mode === 'strum') {
                strumChord(notes, velocity);
            } else if (state.mode === 'pulse') {
                pulseChord(notes, velocity);
            }
        }
        
        function stopChord() {
            // Stop arpeggiator
            if (arpInterval) {
                clearInterval(arpInterval);
                arpInterval = null;
            }
            
            // Record to loop
            if (loopState === 'recording' && audioCtx) {
                const time = audioCtx.currentTime - loopStartTime;
                loopData.push({ type: 'off', time });
            }
            
            // Stop audio nodes
            activeChordNodes.forEach(nodes => stopNoteAudio(nodes));
            activeChordNodes = [];
            
            if (activeBassNode) {
                stopNoteAudio(activeBassNode);
                activeBassNode = null;
            }
            
            // Send MIDI note offs
            if (midiOutput) {
                const notes = getChordNotes();
                notes.forEach(note => sendMidiNoteOff(note, state.chordChannel));
                sendMidiNoteOff(getBassNote(), state.bassChannel);
            }
        }
        
        // ============================================
        // PERFORMANCE MODES
        // ============================================
        
        function startArpeggiator(notes, velocity) {
            arpIndex = 0;
            const interval = (60 / state.bpm) * 250; // 16th notes
            
            let sequence = [...notes];
            if (state.mode === 'harp') {
                sequence = [...notes, ...notes.slice().reverse().slice(1, -1)];
            }
            
            const playNext = () => {
                let noteToPlay;
                if (state.mode === 'random') {
                    noteToPlay = notes[Math.floor(Math.random() * notes.length)];
                } else {
                    noteToPlay = sequence[arpIndex % sequence.length];
                    arpIndex++;
                }
                
                if (midiOutput) {
                    sendMidiNoteOn(noteToPlay, velocity, state.chordChannel);
                    setTimeout(() => sendMidiNoteOff(noteToPlay, state.chordChannel), interval * 0.8);
                } else {
                    const node = playNoteAudio(noteToPlay, velocity);
                    activeChordNodes.push(node);
                    setTimeout(() => stopNoteAudio(node), interval * 0.8);
                }
            };
            
            playNext();
            arpInterval = setInterval(playNext, interval);
        }
        
        function strumChord(notes, velocity) {
            notes.forEach((note, i) => {
                setTimeout(() => {
                    if (midiOutput) {
                        sendMidiNoteOn(note, velocity, state.chordChannel);
                    } else {
                        activeChordNodes.push(playNoteAudio(note, velocity));
                    }
                }, i * 30);
            });
        }
        
        function pulseChord(notes, velocity) {
            const interval = (60 / state.bpm) * 500;
            
            const playPulse = () => {
                notes.forEach(note => {
                    if (midiOutput) {
                        sendMidiNoteOn(note, velocity, state.chordChannel);
                        setTimeout(() => sendMidiNoteOff(note, state.chordChannel), interval * 0.5);
                    } else {
                        const node = playNoteAudio(note, velocity);
                        activeChordNodes.push(node);
                        setTimeout(() => stopNoteAudio(node), interval * 0.5);
                    }
                });
            };
            
            playPulse();
            arpInterval = setInterval(playPulse, interval);
        }
        
        // ============================================
        // KEY FIX v4: Note On/Off with proper tracking
        // ============================================
        
        function noteOn(midiNote, velocity = 100) {
            initAudio();
            
            // Add to held notes
            heldInputNotes.add(midiNote);
            
            // Extract root from MIDI note
            const noteInOctave = midiNote % 12;
            state.rootNote = noteInOctave;
            
            // Update UI
            document.querySelectorAll('.root-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.root) === noteInOctave);
            });
            
            updateChordDisplay();
            
            // Only play chord if this is the first note (no other notes held)
            // OR if we want retriggering behavior
            if (heldInputNotes.size === 1) {
                playChord(velocity / 127);
            } else {
                // Multiple notes held - retrigger with new root
                stopChord();
                playChord(velocity / 127);
            }
        }
        
        function noteOff(midiNote) {
            // Remove from held notes
            heldInputNotes.delete(midiNote);
            
            // ===== KEY FIX: Only stop when ALL notes are released =====
            if (heldInputNotes.size === 0) {
                stopChord();
            }
            // If other notes are still held, do nothing - chord keeps playing
        }
        
        // ============================================
        // MIDI
        // ============================================
        
        async function initMIDI() {
            try {
                midiAccess = await navigator.requestMIDIAccess();
                
                // Auto-connect to MPK
                let foundMPK = false;
                midiAccess.inputs.forEach(input => {
                    const name = input.name.toLowerCase();
                    if (name.includes('mpk') || name.includes('mini')) {
                        connectMidiInput(input);
                        foundMPK = true;
                    }
                });
                
                if (foundMPK) {
                    document.getElementById('statusDot').classList.add('connected');
                    document.getElementById('midiStatus').textContent = 'MPK';
                    document.getElementById('midiBtn').classList.add('connected');
                }
                
            } catch (e) {
                console.log('MIDI not available');
            }
        }
        
        function connectMidiInput(input) {
            if (midiInput) {
                midiInput.onmidimessage = null;
            }
            midiInput = input;
            midiInput.onmidimessage = handleMidiMessage;
        }
        
        function handleMidiMessage(msg) {
            const [status, data1, data2] = msg.data;
            const command = status & 0xf0;
            
            if (command === 0x90 && data2 > 0) {
                // Note On
                noteOn(data1, data2);
            } else if (command === 0x80 || (command === 0x90 && data2 === 0)) {
                // Note Off
                noteOff(data1);
            } else if (command === 0xb0 && data1 === 1) {
                // Mod wheel -> voicing
                state.voicing = Math.floor(data2 / 16);
                document.getElementById('voicingValue').textContent = state.voicing;
                updateKnobVisual('voicingKnob', state.voicing, 0, 7);
                updateChordDisplay();
            }
        }
        
        function sendMidiNoteOn(note, velocity, channel) {
            if (!midiOutput) return;
            const vel = Math.round(velocity * 127);
            midiOutput.send([0x90 | channel, note, vel]);
        }
        
        function sendMidiNoteOff(note, channel) {
            if (!midiOutput) return;
            midiOutput.send([0x80 | channel, note, 0]);
        }
        
        function showMidiModal() {
            const modal = document.getElementById('midiModal');
            const inputSelect = document.getElementById('modalMidiInput');
            const outputSelect = document.getElementById('modalMidiOutput');
            
            // Clear options
            inputSelect.innerHTML = '<option value="">-- Aucune --</option>';
            outputSelect.innerHTML = '<option value="">-- Audio interne --</option>';
            
            if (midiAccess) {
                midiAccess.inputs.forEach(input => {
                    const opt = document.createElement('option');
                    opt.value = input.id;
                    opt.textContent = input.name;
                    if (midiInput && midiInput.id === input.id) opt.selected = true;
                    inputSelect.appendChild(opt);
                });
                
                midiAccess.outputs.forEach(output => {
                    const opt = document.createElement('option');
                    opt.value = output.id;
                    opt.textContent = output.name;
                    if (midiOutput && midiOutput.id === output.id) opt.selected = true;
                    outputSelect.appendChild(opt);
                });
            }
            
            modal.classList.add('show');
        }
        
        function hideMidiModal() {
            document.getElementById('midiModal').classList.remove('show');
        }
        
        function applyMidiSelection() {
            const inputId = document.getElementById('modalMidiInput').value;
            const outputId = document.getElementById('modalMidiOutput').value;
            
            if (inputId && midiAccess) {
                const input = midiAccess.inputs.get(inputId);
                if (input) connectMidiInput(input);
            }
            
            if (outputId && midiAccess) {
                midiOutput = midiAccess.outputs.get(outputId);
            } else {
                midiOutput = null;
            }
            
            // Update status
            document.getElementById('statusDot').classList.toggle('connected', !!midiInput);
            document.getElementById('midiStatus').textContent = midiInput ? midiInput.name.substring(0, 10) : 'MIDI';
            document.getElementById('midiBtn').classList.toggle('connected', !!midiInput);
            
            hideMidiModal();
        }
        
        // ============================================
        // LOOP - Orchid Style
        // ============================================
        
        function toggleLoop() {
            if (loopState === 'stopped') {
                startLoopCountdown();
            } else if (loopState === 'countdown') {
                cancelLoopCountdown();
            } else if (loopState === 'recording') {
                // Shouldn't happen - recording auto-stops
            } else if (loopState === 'playing') {
                stopLoop();
            }
        }
        
        function startLoopCountdown() {
            initAudio();
            loopState = 'countdown';
            countdownCount = 4;
            loopData = [];
            
            const circle = document.getElementById('loopCircle');
            const icon = document.getElementById('loopIcon');
            circle.classList.add('countdown');
            
            const beatTime = 60000 / state.bpm;
            
            const tick = () => {
                icon.textContent = countdownCount;
                playMetronomeClick(true);
                
                countdownCount--;
                if (countdownCount >= 0) {
                    metronomeTimeout = setTimeout(tick, beatTime);
                } else {
                    startLoopRecording();
                }
            };
            
            tick();
        }
        
        function cancelLoopCountdown() {
            if (metronomeTimeout) clearTimeout(metronomeTimeout);
            loopState = 'stopped';
            const circle = document.getElementById('loopCircle');
            circle.classList.remove('countdown');
            document.getElementById('loopIcon').textContent = 'â¬¤';
        }
        
        function startLoopRecording() {
            loopState = 'recording';
            loopStartTime = audioCtx.currentTime;
            loopData = [];
            
            const circle = document.getElementById('loopCircle');
            const icon = document.getElementById('loopIcon');
            circle.classList.remove('countdown');
            circle.classList.add('recording');
            icon.textContent = 'â—';
            
            // Calculate loop duration
            const beatsPerBar = 4;
            const totalBeats = loopBars * beatsPerBar;
            const loopDuration = (60 / state.bpm) * totalBeats * 1000;
            
            // Progress animation
            const progressCircle = document.getElementById('loopProgressCircle');
            const circumference = 289;
            let startTime = Date.now();
            
            const updateProgress = () => {
                if (loopState !== 'recording') return;
                
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / loopDuration, 1);
                progressCircle.style.strokeDashoffset = circumference * (1 - progress);
                progressCircle.style.stroke = 'var(--accent-red)';
                
                if (progress < 1) {
                    requestAnimationFrame(updateProgress);
                }
            };
            
            updateProgress();
            
            // Auto-stop after duration
            setTimeout(() => {
                if (loopState === 'recording') {
                    stopRecordingAndPlay();
                }
            }, loopDuration);
        }
        
        function stopRecordingAndPlay() {
            const circle = document.getElementById('loopCircle');
            const icon = document.getElementById('loopIcon');
            circle.classList.remove('recording');
            
            if (loopData.length > 0) {
                loopState = 'playing';
                circle.classList.add('playing');
                icon.textContent = 'â–¶';
                playLoop();
            } else {
                loopState = 'stopped';
                icon.textContent = 'â¬¤';
                document.getElementById('loopProgressCircle').style.strokeDashoffset = 289;
            }
        }
        
        function playLoop() {
            if (loopState !== 'playing' || loopData.length === 0) return;
            
            const beatsPerBar = 4;
            const totalBeats = loopBars * beatsPerBar;
            const loopDuration = (60 / state.bpm) * totalBeats;
            
            // Schedule all events
            loopData.forEach(event => {
                const delay = event.time * 1000;
                loopPlaybackTimeout = setTimeout(() => {
                    if (loopState !== 'playing') return;
                    if (event.type === 'on') {
                        playChord(event.velocity);
                    } else {
                        stopChord();
                    }
                }, delay);
            });
            
            // Progress animation
            const progressCircle = document.getElementById('loopProgressCircle');
            progressCircle.style.stroke = 'var(--accent-green)';
            const circumference = 289;
            let startTime = Date.now();
            
            const updateProgress = () => {
                if (loopState !== 'playing') return;
                
                const elapsed = Date.now() - startTime;
                const progress = (elapsed / (loopDuration * 1000)) % 1;
                progressCircle.style.strokeDashoffset = circumference * (1 - progress);
                
                requestAnimationFrame(updateProgress);
            };
            
            updateProgress();
            
            // Loop restart
            setTimeout(() => {
                if (loopState === 'playing') {
                    playLoop();
                }
            }, loopDuration * 1000);
        }
        
        function stopLoop() {
            loopState = 'stopped';
            loopData = [];
            
            if (loopPlaybackTimeout) clearTimeout(loopPlaybackTimeout);
            
            const circle = document.getElementById('loopCircle');
            circle.classList.remove('recording', 'playing', 'countdown');
            document.getElementById('loopIcon').textContent = 'â¬¤';
            document.getElementById('loopProgressCircle').style.strokeDashoffset = 289;
            
            stopChord();
        }
        
        function playMetronomeClick(accent = false) {
            if (!audioCtx) return;
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.frequency.value = accent ? 1000 : 800;
            osc.connect(gain);
            gain.connect(masterGain);
            
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);
            
            osc.start();
            osc.stop(audioCtx.currentTime + 0.05);
        }
        
        // ============================================
        // BEAT MACHINE
        // ============================================
        
        function startBeat(pattern) {
            stopBeat();
            if (pattern === 0 || !beatPatterns[pattern]) return;
            
            state.beat = pattern;
            beatStep = 0;
            const stepTime = (60 / state.bpm) / 4 * 1000; // 16th notes
            
            const playStep = () => {
                const p = beatPatterns[state.beat];
                if (!p) return;
                
                if (p.kick.includes(beatStep)) playDrum('kick');
                if (p.snare.includes(beatStep)) playDrum('snare');
                if (p.hat.includes(beatStep)) playDrum('hat');
                
                beatStep = (beatStep + 1) % 16;
            };
            
            playStep();
            beatInterval = setInterval(playStep, stepTime);
        }
        
        function stopBeat() {
            if (beatInterval) {
                clearInterval(beatInterval);
                beatInterval = null;
            }
        }
        
        function playDrum(type) {
            if (!audioCtx) initAudio();
            
            const now = audioCtx.currentTime;
            
            if (type === 'kick') {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                gain.gain.setValueAtTime(0.8, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                osc.connect(gain);
                gain.connect(masterGain);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'snare') {
                const noise = audioCtx.createBufferSource();
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.1, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = buffer;
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                noise.connect(gain);
                gain.connect(masterGain);
                noise.start(now);
            } else if (type === 'hat') {
                const noise = audioCtx.createBufferSource();
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.05, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 8000;
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);
                noise.start(now);
            }
        }
        
        // ============================================
        // PANIC / STOP ALL
        // ============================================
        
        function panic() {
            // Stop all sounds
            stopChord();
            stopBeat();
            stopLoop();
            
            // Clear held notes
            heldInputNotes.clear();
            
            // Send all notes off on all channels
            if (midiOutput) {
                for (let ch = 0; ch < 16; ch++) {
                    midiOutput.send([0xb0 | ch, 123, 0]); // All Notes Off
                    midiOutput.send([0xb0 | ch, 120, 0]); // All Sound Off
                }
            }
        }
        
        // ============================================
        // KNOBS
        // ============================================
        
        function setupKnob(id, min, max, stateKey, updateFn) {
            const knob = document.getElementById(id);
            let startY, startValue;
            
            const onMove = (e) => {
                const y = e.touches ? e.touches[0].clientY : e.clientY;
                const delta = (startY - y) / 100;
                const range = max - min;
                let newValue = Math.round(startValue + delta * range);
                newValue = Math.max(min, Math.min(max, newValue));
                state[stateKey] = newValue;
                updateFn();
                updateChordDisplay();
            };
            
            const onEnd = () => {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onEnd);
                document.removeEventListener('touchmove', onMove);
                document.removeEventListener('touchend', onEnd);
            };
            
            knob.addEventListener('mousedown', (e) => {
                startY = e.clientY;
                startValue = state[stateKey];
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onEnd);
            });
            
            knob.addEventListener('touchstart', (e) => {
                startY = e.touches[0].clientY;
                startValue = state[stateKey];
                document.addEventListener('touchmove', onMove);
                document.addEventListener('touchend', onEnd);
            });
        }
        
        function updateKnobVisual(id, value, min, max) {
            const knob = document.getElementById(id);
            const range = max - min;
            const normalized = (value - min) / range;
            const angle = -135 + (normalized * 270);
            knob.style.transform = 'rotate(' + angle + 'deg)';
        }
        
        function updateVoicingKnob() {
            document.getElementById('voicingValue').textContent = state.voicing;
            updateKnobVisual('voicingKnob', state.voicing, 0, 7);
        }
        
        function updateSpreadKnob() {
            document.getElementById('spreadValue').textContent = state.spread;
            updateKnobVisual('spreadKnob', state.spread, 1, 3);
        }
        
        function updateOctaveKnob() {
            document.getElementById('octaveValue').textContent = state.octave;
            updateKnobVisual('octaveKnob', state.octave, 2, 7);
        }
        
        // ============================================
        // VIRTUAL KEYBOARD
        // ============================================
        
        function createKeyboard() {
            const keyboard = document.getElementById('keyboard');
            const whiteNotes = [48, 50, 52, 53, 55, 57, 59, 60, 62, 64, 65, 67, 69, 71];
            const blackNotes = [
                { note: 49, offset: 20 },
                { note: 51, offset: 48 },
                { note: 54, offset: 104 },
                { note: 56, offset: 132 },
                { note: 58, offset: 160 },
                { note: 61, offset: 216 },
                { note: 63, offset: 244 },
                { note: 66, offset: 300 },
                { note: 68, offset: 328 },
                { note: 70, offset: 356 }
            ];
            
            // White keys
            whiteNotes.forEach(note => {
                const key = document.createElement('div');
                key.className = 'white-key';
                key.dataset.note = note;
                keyboard.appendChild(key);
            });
            
            // Black keys
            blackNotes.forEach(({ note, offset }) => {
                const key = document.createElement('div');
                key.className = 'black-key';
                key.dataset.note = note;
                key.style.left = offset + 'px';
                keyboard.appendChild(key);
            });
        }
        
        // ============================================
        // EVENT SETUP
        // ============================================
        
        function setupEventListeners() {
            // Panic button
            document.getElementById('panicBtn').addEventListener('click', panic);
            
            // MIDI button
            document.getElementById('midiBtn').addEventListener('click', showMidiModal);
            document.getElementById('modalCancel').addEventListener('click', hideMidiModal);
            document.getElementById('modalConnect').addEventListener('click', applyMidiSelection);
            
            // Fullscreen
            document.getElementById('fullscreenBtn').addEventListener('click', () => {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    document.documentElement.requestFullscreen();
                }
            });
            
            // Root notes
            document.querySelectorAll('.root-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.root-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.rootNote = parseInt(btn.dataset.root);
                    updateChordDisplay();
                });
            });
            
            // Chord type
            document.querySelectorAll('#chordTypeGrid .grid-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#chordTypeGrid .grid-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.chordType = btn.dataset.type;
                    updateChordDisplay();
                });
            });
            
            // Extensions
            document.querySelectorAll('#extensionGrid .grid-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#extensionGrid .grid-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.extension = btn.dataset.ext;
                    updateChordDisplay();
                });
            });
            
            // Mode
            document.querySelectorAll('#modeGrid .grid-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#modeGrid .grid-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.mode = btn.dataset.mode;
                });
            });
            
            // Engine
            document.querySelectorAll('#engineGrid .grid-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#engineGrid .grid-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.engine = btn.dataset.engine;
                });
            });
            
            // BPM
            document.getElementById('bpmUp').addEventListener('click', () => {
                state.bpm = Math.min(300, state.bpm + 5);
                document.getElementById('bpmValue').textContent = state.bpm;
            });
            document.getElementById('bpmDown').addEventListener('click', () => {
                state.bpm = Math.max(40, state.bpm - 5);
                document.getElementById('bpmValue').textContent = state.bpm;
            });
            
            // Loop bars
            document.querySelectorAll('#barsSelector .bar-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#barsSelector .bar-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    loopBars = parseInt(btn.dataset.bars);
                });
            });
            
            // Loop circle
            document.getElementById('loopCircle').addEventListener('click', toggleLoop);
            
            // Beat
            document.querySelectorAll('#beatGrid .beat-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#beatGrid .beat-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    startBeat(parseInt(btn.dataset.beat));
                });
            });
            
            // Volume sliders
            document.getElementById('mainVolume').addEventListener('input', (e) => {
                state.mainVolume = e.target.value / 100;
                if (masterGain) masterGain.gain.value = state.mainVolume;
            });
            document.getElementById('bassVolume').addEventListener('input', (e) => {
                state.bassVolume = e.target.value / 100;
            });
            
            // Effect sliders
            document.getElementById('reverbSlider').addEventListener('input', (e) => {
                state.reverb = e.target.value / 100;
                if (reverbGain) reverbGain.gain.value = state.reverb;
            });
            document.getElementById('delaySlider').addEventListener('input', (e) => {
                state.delay = e.target.value / 100;
                if (delayGain) delayGain.gain.value = state.delay;
            });
            
            // MIDI channels
            document.getElementById('chordChannel').addEventListener('change', (e) => {
                state.chordChannel = parseInt(e.target.value);
            });
            document.getElementById('bassChannel').addEventListener('change', (e) => {
                state.bassChannel = parseInt(e.target.value);
            });
            
            // Virtual keyboard
            const keyboard = document.getElementById('keyboard');
            keyboard.addEventListener('mousedown', (e) => {
                if (e.target.dataset.note) {
                    e.target.classList.add('active');
                    noteOn(parseInt(e.target.dataset.note), 100);
                }
            });
            keyboard.addEventListener('mouseup', (e) => {
                if (e.target.dataset.note) {
                    e.target.classList.remove('active');
                    noteOff(parseInt(e.target.dataset.note));
                }
            });
            keyboard.addEventListener('mouseleave', (e) => {
                if (e.target.dataset.note) {
                    e.target.classList.remove('active');
                    noteOff(parseInt(e.target.dataset.note));
                }
            });
            
            // Touch support for keyboard
            keyboard.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.target.dataset.note) {
                    e.target.classList.add('active');
                    noteOn(parseInt(e.target.dataset.note), 100);
                }
            });
            keyboard.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (e.target.dataset.note) {
                    e.target.classList.remove('active');
                    noteOff(parseInt(e.target.dataset.note));
                }
            });
            
            // Knobs
            setupKnob('voicingKnob', 0, 7, 'voicing', updateVoicingKnob);
            setupKnob('spreadKnob', 1, 3, 'spread', updateSpreadKnob);
            setupKnob('octaveKnob', 2, 7, 'octave', updateOctaveKnob);
            
            // Keyboard shortcuts
            const keyMap = { a:48, w:49, s:50, e:51, d:52, f:53, t:54, g:55, y:56, h:57, u:58, j:59, k:60 };
            document.addEventListener('keydown', (e) => {
                if (keyMap[e.key] && !e.repeat) noteOn(keyMap[e.key], 100);
            });
            document.addEventListener('keyup', (e) => {
                if (keyMap[e.key]) noteOff(keyMap[e.key]);
            });
        }
        
        // ============================================
        // INIT
        // ============================================
        
        document.addEventListener('DOMContentLoaded', async () => {
            createKeyboard();
            setupEventListeners();
            updateChordDisplay();
            updateVoicingKnob();
            updateSpreadKnob();
            updateOctaveKnob();
            
            await initMIDI();
        });
    </script>
</body>
</html>
